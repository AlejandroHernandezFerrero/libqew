/* * Copyright (C) 2017 Alejandro Hernández Ferrero * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program.  If not, see <http://www.gnu.org/licenses/>. */package game;import game.Game.Physics;import libqew.ExtensiblePanel;import libqew.TabsPanel;import ui.EnemyUI;import utils.ColorUtils;import utils.GeometryUtils;/** * Define las propiedades de un tipo de enemigo y contiene todos los enemigos de * este tipo. * * @author Alejandro Hernández Ferrero */public class EnemyType extends UnitType {    private float turningSpeed = 0.5f;    private int copies = 1;    private Snake snake;    /**     * Crea un nuevo tipo de enemigo que que seguirá a un objetivo.     *     * @param physics las leyes físicas del juego     * @param snake el objetivo     */    public EnemyType(Physics physics, Snake snake) {        super(physics);        this.snake = snake;    }    /**     * Crea una copia de un tipo de enemigo.     *     * @param enemy el tipo a copiar     */    public EnemyType(EnemyType enemy) {        this(enemy.physics(), enemy.getTarget());        setAngularSpeed(enemy.getAngularSpeed());        setBorder(enemy.hasBorder());        setBorderColor(new ColorUtils.ColorName(enemy.getBorderColor()));        setBorderWidth(enemy.getBorderWidth());        setClockwise(enemy.isClockwise());        setColor(new ColorUtils.ColorName(enemy.getColor()));        setCopies(enemy.getCopies());        setFilled(enemy.isFilled());        setInitialAngle(enemy.getInitialAngle());        setRadius(enemy.getRadius());        setRotation(enemy.hasRotation());        setSides(enemy.getSides());        setSpeed(enemy.getSpeed());        setTurningSpeed(enemy.getTurningSpeed());    }    @Override    public void init() {        super.init();        for (int i = 0; i < copies; i++) {            new Enemy();        }    }    /**     * Obtiene el objetivo.     *     * @return el objetivo     */    public Snake getTarget() {        return snake;    }    /**     * Establece el objetivo.     *     * @param snake el objetivo     */    public void setTarget(Snake snake) {        this.snake = snake;    }    @Override    public ExtensiblePanel getUI() {        TabsPanel ui = (TabsPanel) super.getUI();        ((ExtensiblePanel) ui.getTab(1)).addChild(new EnemyUI(this));// Se extiende la 2ª pestaña        return ui;    }    @Override    public String toString() {        return getColor().toString() + " " + GeometryUtils.getPolygonName(getSides());    }    /**     * Obtiene el número de copias.     *     * @return el número de copias     */    public int getCopies() {        return copies;    }    /**     * Establece el número de copias.     *     * @param copies el número de copias     */    public void setCopies(int copies) {        this.copies = copies;    }    /**     * Obtiene la velocidad de giro.     *     * @return la velocidad de giro, en revoluciones por segundo     */    public float getTurningSpeed() {        return turningSpeed;    }    /**     * Establece la velocidad de giro.     *     * @param turningSpeed la velocidad de giro, en revoluciones por segundo     */    public void setTurningSpeed(float turningSpeed) {        this.turningSpeed = turningSpeed;    }    /**     * Enemigo particular con las características comunes de este tipo.     */    public class Enemy extends Unit {        private double direction;        private double sight;        private float bounceTime;        private double bounceAngle;        private float bouncingSpeed;        private boolean bouncing;        @Override        public double getDirection() {            return direction;        }        @Override        public boolean isMoving() {            return true; // Siempre se moverán        }        @Override        public boolean isRotating() {            return !isBouncing(); // Mientras rebota no gira        }        @Override        public void bounce(float speed, double angle) {            // Se posponen los efectos hasta el siguiente ciclo            // Así se ignoran rebotes múltiples en el mismo            bouncingSpeed = speed;            bounceAngle = angle;            bounceTime = getRadius() * 2 / speed; // Rebotará la distancia de su diámetro            if (!isBouncing()) {                sight = direction;            }        }        @Override        public float getSpeed() {            return bouncing ? bouncingSpeed : super.getSpeed();        }        @Override        public boolean isBouncing() {            return bouncing;        }        @Override        public void update(float deltaTime) {            float spin;            if (bounceTime > 0) { // Si está rebotando                spin = 0; // No girará                if (bounceTime < deltaTime) { // Deja de rebotar                    direction = sight; // Sigue en la dirección contraria al rebote                    bounceTime = 0;                    bouncing = false;                } else {                    bouncing = true;                    direction = bounceAngle;                    bounceTime -= deltaTime;                }            } else {                spin = getTurningSpeed();            }            Shape target = getTarget();            float dx = target.getX() - getX();            float dy = target.getY() - getY();            double targetAngle = Math.atan2(dy, dx); // �?ngulo hasta el objetivo            double delta = (((targetAngle - direction + 3 * Math.PI) % (2 * Math.PI)) - Math.PI); // Ajusta el ángulo por el sentido más cercano            delta = Math.min(delta, deltaTime * spin * 2 * Math.PI); // Giro que le corresponde en ese tiempo            delta = Math.max(delta, -deltaTime * spin * 2 * Math.PI);            double old = direction;            direction = direction + delta;            if (!move(deltaTime)) {                direction = old; // Si no se permitió el movimiento se deshacen los cambios            }        }        /**         * Busca la parte más cercana de la serpiente.         */        private Shape getTarget() {            double maxDist = Double.MAX_VALUE;            Shape maxTarget = null;            for (Shape target : snake.getShapes()) {                float dx = target.getX() - getX();                float dy = target.getY() - getY();                double dist = Math.hypot(dx, dy);                if (dist < maxDist) {                    maxDist = dist;                    maxTarget = target;                }            }            return maxTarget;        }        @Override        public String toString() {            return EnemyType.this.toString();        }    }}